


ARM Macro Assembler    Page 1 


    1 00000000 00000000 
                       Const1  EQU              0x00
    2 00000000 00000011 
                       Const2  EQU              0x11
    3 00000000 40021018 
                       APB2PC_ENR
                               EQU              0x40021018
    4 00000000 40010804 
                       GPIOA_CRH
                               EQU              0x40010804
    5 00000000 40013808 
                       USART1_BRR
                               EQU              0x40013808
    6 00000000 4001380C 
                       USART1_CR1
                               EQU              0x4001380C
    7 00000000 40013800 
                       USART1_SR
                               EQU              0x40013800
    8 00000000 40013804 
                       USART1_DR
                               EQU              0x40013804
    9 00000000         
   10 00000000                 AREA             Mydata, DATA, READWRITE
   11 00000000         
   12 00000000         ; your readwrite data goes here
   13 00000000 00 00   Readwrite1
                               space            2
   14 00000002 00 00 00 
              00 00 00 
              00       Readwrite2
                               space            7
   15 00000009 00 00 00 
              00 00 00 ASCII_CHARS
                               space            6           ;each ascii char is
                                                             8-bits or 1 byte
   16 0000000F         
   17 0000000F                 AREA             DATAINIT, DATA, READONLY
   18 00000000 41      ASCII   DCB              'A'
   19 00000001         
   20 00000001                 AREA             ARMex, CODE, READONLY
   21 00000000         
   22 00000000         serialIO
                               PROC
   23 00000000                 EXPORT           serialIO
   24 00000000         
   25 00000000 B500            push             {LR}
   26 00000002 F7FF FFFE       bl               initcom
   27 00000006 BF00            nop
   28 00000008 F04F 0016       mov              R0, 0x16
   29 0000000C F7FF FFFE       bl               checkcom
   30 00000010 F04F 0116       mov              R1, 0x16
   31 00000014 F7FF FFFE       bl               getchar
   32 00000018 F7FF FFFE       bl               testChComp
   33 0000001C F85D EB04       pop              {LR}
   34 00000020 4770            bx               LR
   35 00000022         ;done  b done
   36 00000022                 ENDP
   37 00000022         



ARM Macro Assembler    Page 2 


   38 00000022         
   39 00000022         
   40 00000022         initcom PROC
   41 00000022                 EXPORT           initcom
   42 00000022 B500            push             {lr}
   43 00000024 B401            push             {R0}        ;address variable
   44 00000026 B402            push             {R1}        ;value variable
   45 00000028 B404            push             {R2}
   46 0000002A         ; your program goes here
   47 0000002A BF00            nop
   48 0000002C         ;;[XXX]INITCOM1: initializing bus clock
   49 0000002C 484D            LDR              R0, =APB2PC_ENR
   50 0000002E F244 0105       MOV              R1, #0x4005 ;need to write 0100
                                                            -0000-0000-0101 <=>
                                                             0x4005
   51 00000032 6802            LDR              R2, [R0]
   52 00000034 EA42 0201       ORR              R2, R1
   53 00000038 6002            STR              R2, [R0]    ;store the val in R
                                                            1 into the address 
                                                            for R0, which is AP
                                                            B2PC_ENR
   54 0000003A         ;for this application it is fine to just force the value
                       s exactly as we want
   55 0000003A         ;since we do not need to enable multiple peripherals at 
                       different points in
   56 0000003A         ;program execution. In a case where we might have softwa
                       re turn on GPIO in response
   57 0000003A         ;to something it sees, then we would want to ORR here.
   58 0000003A         
   59 0000003A         ;;[XXX]INITCOM2: Configure GPIO ports
   60 0000003A         ;;      assume that you have some initial state in the G
                       PIO ports that you do not want
   61 0000003A         ;;      to change. Thus you need some operator that allo
                       ws you to impact only the bits that 
   62 0000003A         ;;      you want to change. So if we write 
   63 0000003A         ;;      [conclusion = not and] hyp1 :if we do DESIRED an
                       d PREVIOUS
   64 0000003A         ;;            Test 0111 AND 1111 = 0111, but 0111 and 00
                       00 = 0000 
   65 0000003A         ;;      [conclusion = not or ] hyp2: DESIRED or PREVIOUS
                       
   66 0000003A         ;;          Test 0111 or 1111 = 1111, but 0111 and 0000 
                       = 0111, which is not
   67 0000003A         ;;          what we want because we want it to just set 
                       the bits exactly as we specify
   68 0000003A         ;;          but it would be useful for the case where yo
                       u want to keep what high as high.
   69 0000003A         ;;      [conclusion = not xor]
   70 0000003A         ;;      --> [conclusion = need two step process, need to
                        be able to control the exact state.
   71 0000003A         ;;                  Professor's suggestion is to use and
                        to keep high's as high but zero
   72 0000003A         ;;                  out the bits to change
   73 0000003A 484B            LDR              R0, =GPIOA_CRH ;set the address
                                                             register
   74 0000003C F46F 617F       LDR              R1, = 0xFFFFF00F ; 0x...P10P9P8
                                                            , so we want to use
                                                             this to filter out
                                                             the bits that



ARM Macro Assembler    Page 3 


   75 00000040         ; we want to set exactly. We will then combine it with o
                       rr to get the exact bit
   76 00000040         ; pattern that we want
   77 00000040         ; AND R1, [R0]           ; Why can't you do this? Becaus
                       e [R0] needs to be loaded to memory
   78 00000040 6802            LDR              R2,[R0]
   79 00000042 EA01 0102       AND              R1, R2      ;Now we have cleare
                                                            d the bits we want 
                                                            to and saved that t
                                                            o R1
   80 00000046 F441 6196       ORR              R1, 0x04B0  ;0d4,0d11,0 <=> 0x0
                                                            4B0 ;since we are o
                                                            rr'ing the things t
                                                            hat we don't change
                                                             must
   81 0000004A         ;be set as zero. Want 10 as input and 9 as AFOutput max 
                       speed. 
   82 0000004A 6001            STR              R1, [R0]    ;so we have set the
                                                             
   83 0000004C         
   84 0000004C         
   85 0000004C         ;;[Test? CHECK IN HW] [XXX]INITCOM3: modify the BRR regi
                       ster
   86 0000004C         ;;so this is where we will set our baudrate
   87 0000004C 4847            LDR              R0, =USART1_BRR
   88 0000004E F04F 01D0       MOV              R1, #0x00D0 ;13 for mantissa an
                                                            d zero for fraction
                                                            .
   89 00000052 6001            STR              R1, [R0]    ;put the desired bi
                                                            t pattern into R0 f
                                                            rom R1
   90 00000054         
   91 00000054         ;;[Test= check TX in HW ] [ ] INITCOM4: Configuring USAR
                       T1_CR1
   92 00000054         
   93 00000054         ;0010|0000|0000|1100 <=> 0x200C
   94 00000054 4846            LDR              R0, =USART1_CR1
   95 00000056 F242 010C       MOV              R1, #0x200C
   96 0000005A 6001            STR              R1, [R0]
   97 0000005C         
   98 0000005C         
   99 0000005C         
  100 0000005C BC04            pop              {R2}
  101 0000005E BC02            pop              {R1}
  102 00000060 BC01            pop              {R0}
  103 00000062 F85D EB04       pop              {lr}
  104 00000066 4770            bx               lr
  105 00000068                 ENDP
  106 00000068         
  107 00000068         
  108 00000068         
  109 00000068         checkcom
                               PROC
  110 00000068                 EXPORT           checkcom
  111 00000068         ;; [PASS!] TCCC1: register state is x000020c0, should go
                        through NODATA
  112 00000068         ;; [     ] TCCC2: HW test setting RXNE to both states
  113 00000068         ;; [PASS!] TCCC3: Set R3 = 0x70, expect R0 output to be 
                       FF



ARM Macro Assembler    Page 4 


  114 00000068 B500            push             {lr}
  115 0000006A E92D 03FE       push             {R1-R9}
  116 0000006E         
  117 0000006E 4941            LDR              R1, =USART1_SR
  118 00000070         ;;Inspect bit 5 RXNE of above register
  119 00000070 F04F 0220       LDR              R2, =0x00000020 ;0x000000|X=bit
                                                            s7654=>desired0010=
                                                            >0x2|X=3210
  120 00000074 780B    READSTATUS
                               LDRB             R3, [R1]    ;returned zero
  121 00000076         ;LDRH R3, [R0]  ;returned 
  122 00000076         ;; START EXIT PATTERN1: mask pattern based on having eq 
                       branch away
  123 00000076 421A            TST              R2, R3      ;;returns R2 AND R3
                                                            , 0 if RXNE=0
  124 00000078 D002            beq              NODATA      ;;if zero flag is u
                                                            p no data was there
                                                            
  125 0000007A F04F 00FF       MOV              R0, #0xFF
  126 0000007E E001            b                EXIT
  127 00000080         ;; END EXIT PATTERN1
  128 00000080         
  129 00000080         
  130 00000080         
  131 00000080         
  132 00000080         ;;output to R0 if data is present FF, else 0
  133 00000080 F04F 0000 
                       NODATA  MOV              R0, #0x0
  134 00000084         
  135 00000084         
  136 00000084 E8BD 03FE 
                       EXIT    pop              {R1-R9}
  137 00000088 F85D EB04       pop              {lr}
  138 0000008C 4770            bx               lr
  139 0000008E                 ENDP
  140 0000008E         
  141 0000008E         getchar PROC
  142 0000008E                 EXPORT           getchar
  143 0000008E B500            push             {lr}
  144 00000090         ;TCC4: verify this in hardware debuggers
  145 00000090         
  146 00000090 B406            push             {r1-r2}
  147 00000092         
  148 00000092 4939            LDR              R1,=USART1_DR
  149 00000094 780A            LDRB             R2, [R1]    ;;since we have 8 d
                                                            ata we just load th
                                                            e whole byte
  150 00000096 F002 007F       AND              R0, R2, #0x7F ; 0111|1111
  151 0000009A         
  152 0000009A BC06            pop              {r1-r2}
  153 0000009C F85D EB04       pop              {lr}
  154 000000A0 4770            bx               lr
  155 000000A2                 ENDP
  156 000000A2         
  157 000000A2         showchar
                               PROC
  158 000000A2                 EXPORT           showchar
  159 000000A2         
  160 000000A2 B500            push             {lr}



ARM Macro Assembler    Page 5 


  161 000000A4         ; your program goes here
  162 000000A4 B406            push             {r1-r2}
  163 000000A6 B418            push             {r3-r4}
  164 000000A8 4B32            LDR              R3, =USART1_SR
  165 000000AA 781C    CHECKTXE
                               LDRB             R4, [R3]
  166 000000AC F014 0F80       TST              R4, #0x80   ; 8 = 1000, so bit 
                                                            7, or eigth bit is 
                                                            expected high
  167 000000B0 D0FB            BEQ              CHECKTXE    ; loop if the above
                                                             is zero, aka TXE i
                                                            s not set or ready.
                                                            
  168 000000B2 4931            LDR              R1, =USART1_DR
  169 000000B4 7008            STRB             R0, [R1]    ;this stores the lo
                                                            west byte of R0 whi
                                                            ch should contain j
                                                            ust ascii char
  170 000000B6 BC18            pop              {r3-r4}
  171 000000B8 BC06            pop              {r1-r2}
  172 000000BA F85D EB04       pop              {lr}
  173 000000BE 4770            bx               lr
  174 000000C0                 ENDP
  175 000000C0         testChComp
                               PROC
  176 000000C0                 EXPORT           testChComp
  177 000000C0         ;;Conclusion: you can save comparison characters and use
                        that to compare
  178 000000C0         ;;we'll do this and export it
  179 000000C0 B500            push             {lr}
  180 000000C2         ; your program goes here
  181 000000C2 492E            LDR              R1,=ASCII
  182 000000C4 780A            LDRB             R2,[R1]
  183 000000C6 4290            CMP              R0, R2      ;sould set zero fla
                                                            g if R0 = 41
  184 000000C8 F85D EB04       pop              {lr}
  185 000000CC 4770            bx               lr
  186 000000CE                 ENDP
  187 000000CE         
  188 000000CE         bindec  PROC
  189 000000CE                 EXPORT           bindec
  190 000000CE B500            push             {lr}
  191 000000D0 F84D AD04       push             {R10}
  192 000000D4         
  193 000000D4 F8DF B0A8       ldr              R11, =ASCII_CHARS ; Load addres
                                                            s of allocated memo
                                                            ry into R11
  194 000000D8 B200            sxth             R0          ; Sign extend the 1
                                                            6 bit value to 32 b
                                                            its
  195 000000DA 2800            cmp              R0, #0      ; Test first bit of
                                                             R11 to determine i
                                                            f number is pos or 
                                                            neg
  196 000000DC D500            bpl              pos         ; Branch positive
  197 000000DE D404            bmi              negative    ; Branch negative
  198 000000E0         
  199 000000E0         pos                                  ; Write space in fi
                                                            rst byte of array, 



ARM Macro Assembler    Page 6 


                                                            increment address t
                                                            o end of bindec_arr
                                                            
  200 000000E0 F04F 0A20       mov              R10, #0x20  ; Set R10 equal to 
                                                            0x20, which is the 
                                                            ascii code for spac
                                                            e
  201 000000E4 F80B AB05       strb             R10, [R11], #5 ; Store space ch
                                                            aracter in first by
                                                            te of bindec_arr, i
                                                            ncrement address in
                                                             R11 to end of bind
                                                            ec_arr
  202 000000E8 E008            b                bitconv     ; Branch to bit con
                                                            version
  203 000000EA         
  204 000000EA         negative                             ; Put minus sign in
                                                             first byte of arra
                                                            y, increment addres
                                                            s to end of bindec_
                                                            arr
  205 000000EA F04F 0A2D       mov              R10, #0x2D  ; Set R10 equal to 
                                                            0x2D, which is the 
                                                            ascii code for -
  206 000000EE F80B AB05       strb             R10, [R11], #5 ; Store - charac
                                                            ter in first byte o
                                                            f bindec_arr, incre
                                                            ment address in R11
                                                             to end of bindec_a
                                                            rr
  207 000000F2         ;   sxth R1
  208 000000F2 4602            mov              R2, R0      ; Temporarily store
                                                             R1 value in R2
  209 000000F4 EBA0 0002       sub              R0, R2      ; Flip sign of R1 f
                                                            rom positive to neg
                                                            ative using success
                                                            ive subtractions
  210 000000F8 EBA0 0002       sub              R0, R2
  211 000000FC         
  212 000000FC F04F 0205 
                       bitconv mov              R2, #0x5    ; Set R2 as loop co
                                                            unter
  213 00000100 4605            mov              R5, R0      ; Copy value in R1 
                                                            to R5, as division 
                                                            loop expects this
  214 00000102 E007    bitset  b                divide      ; Branch to divide
  215 00000104 F105 0530 
                       postdiv add              R5, #0x30
  216 00000108 F80B 5901       strb             R5, [R11], #-1 ; Store remainde
                                                            r of division held 
                                                            in R5 to the last b
                                                            yte in bindec_arr, 
                                                            increment address i
                                                            n R11 back 1
  217 0000010C 4635            mov              R5, R6      ; Move the quotient
                                                             value from R6 to R
                                                            5 to prepare for ne
                                                            xt division operati
                                                            on



ARM Macro Assembler    Page 7 


  218 0000010E 3A01            subs             R2, #1      ; Decrement loop co
                                                            unter
  219 00000110 D1F7            bne              bitset      ; Loop again if R2 
                                                            > 0
  220 00000112 E00C            b                binstop     ; Branch to the end
                                                             of the subroutine 
                                                            if R2 = 0
  221 00000114         
  222 00000114 BF00    divide  nop
  223 00000116 F04F 0600       mov              R6, #0      ; Set R6 (quotient 
                                                            value) to 0
  224 0000011A 3D0A    divloop subs             R5, #0xA    ; This branch divid
                                                            es by successive su
                                                            btraction until R5 
                                                            is negative
  225 0000011C F106 0601       add              R6, #0x1
  226 00000120 2D00            cmp              R5, #0
  227 00000122 D5FA            bpl              divloop
  228 00000124 F105 050A       add              R5, #0xA    ; Increment R5 by 1
                                                            0 to account for 1 
                                                            too many loops
  229 00000128 F1A6 0601       sub              R6, #0x1    ; Increment R6 by 1
                                                             to account for 1 t
                                                            oo many loops
  230 0000012C E7EA            b                postdiv     ; Branch back to bi
                                                            tset loop
  231 0000012E         
  232 0000012E BF00    binstop nop
  233 00000130         
  234 00000130 F85D AB04       pop              {R10}
  235 00000134 F85D EB04       pop              {lr}
  236 00000138 4770            bx               lr
  237 0000013A                 ENDP
  238 0000013A         
  239 0000013A         shownum PROC
  240 0000013A                 EXPORT           shownum
  241 0000013A B500            push             {lr}
  242 0000013C B43E            push             {r1-r5}
  243 0000013E         ; your program goes here
  244 0000013E         ;;ASSUMES that R0 contains counter
  245 0000013E         ;ASCII_CHARS
  246 0000013E         
  247 0000013E F7FF FFFE       bl               bindec
  248 00000142 F04F 0101       MOV              R1, #1      ;;start the counter
                                                            
  249 00000146 4A0E            LDR              R2, =ASCII_CHARS
  250 00000148 F812 0B01 
                       LOOPSTART
                               LDRB             R0, [R2], #1 ;post-index, so no
                                                            w it is offset
  251 0000014C F7FF FFFE       bl               showchar
  252 00000150 2906            CMP              R1, #6
  253 00000152 F101 0101       ADD              R1, #1
  254 00000156 D1F7            bne              LOOPSTART   ;will fail once R1 
                                                            has just been set f
                                                            or 7th iteration
  255 00000158         ;which means we went thru 6 times.
  256 00000158         
  257 00000158         



ARM Macro Assembler    Page 8 


  258 00000158 BC3E            pop              {r1-r5}
  259 0000015A BF00            nop
  260 0000015C         
  261 0000015C F85D EB04       pop              {lr}
  262 00000160 4770            bx               lr
  263 00000162                 ENDP
  264 00000162         
  265 00000162                 END
              00 00 40021018 
              40010804 
              40013808 
              4001380C 
              40013800 
              40013804 
              00000000 
              00000000 
Command Line: --debug --xref --diag_suppress=9931 --cpu=Cortex-M3 --apcs=interw
ork --depend=.\serialio.d -o.\serialio.o -I.\RTE\_CTemplate -IC:\Users\alexa\Ap
pData\Local\Arm\Packs\ARM\CMSIS\6.1.0\CMSIS\Core\Include -IC:\Users\alexa\AppDa
ta\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include --predefine="__EVAL 
SETA 1" --predefine="__MICROLIB SETA 1" --predefine="__UVISION_VERSION SETA 528
" --predefine="_RTE_ SETA 1" --predefine="STM32F10X_MD_VL SETA 1" --list=.\seri
alio.lst serialIO.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

ASCII_CHARS 00000009

Symbol: ASCII_CHARS
   Definitions
      At line 15 in file serialIO.s
   Uses
      At line 193 in file serialIO.s
      At line 249 in file serialIO.s

Mydata 00000000

Symbol: Mydata
   Definitions
      At line 10 in file serialIO.s
   Uses
      None
Comment: Mydata unused
Readwrite1 00000000

Symbol: Readwrite1
   Definitions
      At line 13 in file serialIO.s
   Uses
      None
Comment: Readwrite1 unused
Readwrite2 00000002

Symbol: Readwrite2
   Definitions
      At line 14 in file serialIO.s
   Uses
      None
Comment: Readwrite2 unused
4 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

ASCII 00000000

Symbol: ASCII
   Definitions
      At line 18 in file serialIO.s
   Uses
      At line 181 in file serialIO.s
Comment: ASCII used once
DATAINIT 00000000

Symbol: DATAINIT
   Definitions
      At line 17 in file serialIO.s
   Uses
      None
Comment: DATAINIT unused
2 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

ARMex 00000000

Symbol: ARMex
   Definitions
      At line 20 in file serialIO.s
   Uses
      None
Comment: ARMex unused
CHECKTXE 000000AA

Symbol: CHECKTXE
   Definitions
      At line 165 in file serialIO.s
   Uses
      At line 167 in file serialIO.s
Comment: CHECKTXE used once
EXIT 00000084

Symbol: EXIT
   Definitions
      At line 136 in file serialIO.s
   Uses
      At line 126 in file serialIO.s
Comment: EXIT used once
LOOPSTART 00000148

Symbol: LOOPSTART
   Definitions
      At line 250 in file serialIO.s
   Uses
      At line 254 in file serialIO.s
Comment: LOOPSTART used once
NODATA 00000080

Symbol: NODATA
   Definitions
      At line 133 in file serialIO.s
   Uses
      At line 124 in file serialIO.s
Comment: NODATA used once
READSTATUS 00000074

Symbol: READSTATUS
   Definitions
      At line 120 in file serialIO.s
   Uses
      None
Comment: READSTATUS unused
bindec 000000CE

Symbol: bindec
   Definitions
      At line 188 in file serialIO.s
   Uses
      At line 189 in file serialIO.s
      At line 247 in file serialIO.s

binstop 0000012E




ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

Symbol: binstop
   Definitions
      At line 232 in file serialIO.s
   Uses
      At line 220 in file serialIO.s
Comment: binstop used once
bitconv 000000FC

Symbol: bitconv
   Definitions
      At line 212 in file serialIO.s
   Uses
      At line 202 in file serialIO.s
Comment: bitconv used once
bitset 00000102

Symbol: bitset
   Definitions
      At line 214 in file serialIO.s
   Uses
      At line 219 in file serialIO.s
Comment: bitset used once
checkcom 00000068

Symbol: checkcom
   Definitions
      At line 109 in file serialIO.s
   Uses
      At line 29 in file serialIO.s
      At line 110 in file serialIO.s

divide 00000114

Symbol: divide
   Definitions
      At line 222 in file serialIO.s
   Uses
      At line 214 in file serialIO.s
Comment: divide used once
divloop 0000011A

Symbol: divloop
   Definitions
      At line 224 in file serialIO.s
   Uses
      At line 227 in file serialIO.s
Comment: divloop used once
getchar 0000008E

Symbol: getchar
   Definitions
      At line 141 in file serialIO.s
   Uses
      At line 31 in file serialIO.s
      At line 142 in file serialIO.s

initcom 00000022

Symbol: initcom



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 40 in file serialIO.s
   Uses
      At line 26 in file serialIO.s
      At line 41 in file serialIO.s

negative 000000EA

Symbol: negative
   Definitions
      At line 204 in file serialIO.s
   Uses
      At line 197 in file serialIO.s
Comment: negative used once
pos 000000E0

Symbol: pos
   Definitions
      At line 199 in file serialIO.s
   Uses
      At line 196 in file serialIO.s
Comment: pos used once
postdiv 00000104

Symbol: postdiv
   Definitions
      At line 215 in file serialIO.s
   Uses
      At line 230 in file serialIO.s
Comment: postdiv used once
serialIO 00000000

Symbol: serialIO
   Definitions
      At line 22 in file serialIO.s
   Uses
      At line 23 in file serialIO.s
Comment: serialIO used once
showchar 000000A2

Symbol: showchar
   Definitions
      At line 157 in file serialIO.s
   Uses
      At line 158 in file serialIO.s
      At line 251 in file serialIO.s

shownum 0000013A

Symbol: shownum
   Definitions
      At line 239 in file serialIO.s
   Uses
      At line 240 in file serialIO.s
Comment: shownum used once
testChComp 000000C0

Symbol: testChComp
   Definitions



ARM Macro Assembler    Page 4 Alphabetic symbol ordering
Relocatable symbols

      At line 175 in file serialIO.s
   Uses
      At line 32 in file serialIO.s
      At line 176 in file serialIO.s

22 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

APB2PC_ENR 40021018

Symbol: APB2PC_ENR
   Definitions
      At line 3 in file serialIO.s
   Uses
      At line 49 in file serialIO.s
Comment: APB2PC_ENR used once
Const1 00000000

Symbol: Const1
   Definitions
      At line 1 in file serialIO.s
   Uses
      None
Comment: Const1 unused
Const2 00000011

Symbol: Const2
   Definitions
      At line 2 in file serialIO.s
   Uses
      None
Comment: Const2 unused
GPIOA_CRH 40010804

Symbol: GPIOA_CRH
   Definitions
      At line 4 in file serialIO.s
   Uses
      At line 73 in file serialIO.s
Comment: GPIOA_CRH used once
USART1_BRR 40013808

Symbol: USART1_BRR
   Definitions
      At line 5 in file serialIO.s
   Uses
      At line 87 in file serialIO.s
Comment: USART1_BRR used once
USART1_CR1 4001380C

Symbol: USART1_CR1
   Definitions
      At line 6 in file serialIO.s
   Uses
      At line 94 in file serialIO.s
Comment: USART1_CR1 used once
USART1_DR 40013804

Symbol: USART1_DR
   Definitions
      At line 8 in file serialIO.s
   Uses
      At line 148 in file serialIO.s
      At line 168 in file serialIO.s

USART1_SR 40013800




ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Absolute symbols

Symbol: USART1_SR
   Definitions
      At line 7 in file serialIO.s
   Uses
      At line 117 in file serialIO.s
      At line 164 in file serialIO.s

8 symbols
373 symbols in table
